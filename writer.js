/*jslint node: true */
"use strict";

var _					= require( 'lodash' );
var _async				= require( 'async' );
var _log				= require( './log.js' );
var _constants				= require( './constants.js' );
var _conf				= require( './conf.js' );
var _storage				= require( './storage.js' );
var _db					= require( './db.js' );
var _object_hash			= require( './object_hash.js' );
var _mutex				= require( './mutex.js' );
var _main_chain				= require( './main_chain.js' );
var _definition				= require( './definition.js' );
var _event_bus				= require( './event_bus.js' );
var _profilerex				= require( './profilerex.js' );


var m_nCountWrites			= 0;
var m_nCountUnitsInPrevAnalyze		= 0;

var m_nStartTime			= 0;
var m_nPrevTime				= 0;





/**
 *	save joint
 */
function saveJoint( objJoint, objValidationState, preCommitCallback, onDone )
{
	var objUnit	= objJoint.unit;
	_log.consoleLog( "\nsaving unit " + objUnit.unit );

	//	PPP
	_profilerex.begin( 'writer-saveJoint-takeConnectionFromPool' );

	//
	//	...
	//
	_db.takeConnectionFromPool
	(
		function( conn )
		{
			var arrQueries = [];
			var i;
			var j;
			var objAdditionalQuery;
			var fields;
			var values;
			var params;
			var bGenesis;

			var address;
			var arrAuthorAddresses;
			var author;
			var definition;
			var definition_chash;

			var path;
			var message;
			var text_payload;
			var poll;
			var vote;
			var attestation;
			var field;
			var value;
			var asset;
			var asset_attestors;
			var data;
			var feed_name;
			var field_name;
			var objSpendProof;
			var recipient;
			var my_best_parent_unit;


			//	PPP
			_profilerex.end( 'writer-saveJoint-takeConnectionFromPool' );

			//	...
			conn.addQuery( arrQueries, "BEGIN" );

			//
			//	additional queries generated by the validator,
			//	used only when received a doublespend
			//
			for ( i = 0; i < objValidationState.arrAdditionalQueries.length; i ++ )
			{
				objAdditionalQuery = objValidationState.arrAdditionalQueries[ i ];
				_log.consoleLog( "----- applying additional queries: " + objAdditionalQuery.sql );
				conn.addQuery
				(
					arrQueries,
					objAdditionalQuery.sql,
					objAdditionalQuery.params
				);
			}


			//
			//	Add new unit
			//
			fields	= "unit, version, alt, witness_list_unit, last_ball_unit, headers_commission, payload_commission, sequence, content_hash";
			values	= "?,?,?,?,?,?,?,?,?";
			params	=
				[
					objUnit.unit,
					objUnit.version,
					objUnit.alt,
					objUnit.witness_list_unit,
					objUnit.last_ball_unit,
					objUnit.headers_commission || 0,
					objUnit.payload_commission || 0,
					objValidationState.sequence,
					objUnit.content_hash
				];
			if ( _conf.bLight )
			{
				fields += ", main_chain_index, creation_date";
				values += ",?," + conn.getFromUnixTime( "?" );
				params.push
				(
					objUnit.main_chain_index,
					objUnit.timestamp
				);
			}
			conn.addQuery
			(
				arrQueries,
				"INSERT INTO units (" + fields + ") VALUES (" + values + ")",
				params
			);


			//
			//	* FOR NOT LIGHT
			//	save balls, hash_tree_balls, skiplist_units
			//
			if ( objJoint.ball && ! _conf.bLight )
			{
				conn.addQuery
				(
					arrQueries,
					"INSERT INTO balls (ball, unit) VALUES(?,?)",
					[
						objJoint.ball,
						objUnit.unit
					]
				);
				conn.addQuery
				(
					arrQueries,
					"DELETE FROM hash_tree_balls WHERE ball=? AND unit=?",
					[
						objJoint.ball,
						objUnit.unit
					]
				);

				if ( objJoint.skiplist_units )
				{
					for ( i = 0; i < objJoint.skiplist_units.length; i ++ )
					{
						conn.addQuery
						(
							arrQueries,
							"INSERT INTO skiplist_units (unit, skiplist_unit) VALUES (?,?)",
							[
								objUnit.unit,
								objJoint.skiplist_units[ i ]
							]
						);
					}
				}
			}

			//
			//	insert parenthoods
			//
			if ( objUnit.parent_units )
			{
				for ( i = 0; i < objUnit.parent_units.length; i ++ )
				{
					conn.addQuery
					(
						arrQueries,
						"INSERT INTO parenthoods (child_unit, parent_unit) VALUES(?,?)",
						[
							objUnit.unit,
							objUnit.parent_units[ i ]
						]
					);
				}
			}

			//
			//	update status of parent units
			//
			bGenesis = _storage.isGenesisUnit( objUnit.unit );
			if ( bGenesis )
			{
				conn.addQuery
				(
					arrQueries,
					"UPDATE units SET is_on_main_chain=1, main_chain_index=0, is_stable=1, level=0, witnessed_level=0 \n\
					WHERE unit=?",
					[
						objUnit.unit
					]
				);
			}
			else
			{
				conn.addQuery
				(
					arrQueries,
					"UPDATE units SET is_free=0 WHERE unit IN(?)",
					[
						objUnit.parent_units
					],
					function( result )
					{
						var count_consumed_free_units;

						//	in sqlite3, result.affectedRows actually returns the number of _matched_ rows
						count_consumed_free_units	= result.affectedRows;
						_log.consoleLog( count_consumed_free_units + " free units consumed" );

						//
						//	update status of unit in _storage
						//
						objUnit.parent_units.forEach
						(
							function( parent_unit )
							{
								if ( _storage.assocUnstableUnits[ parent_unit ] )
								{
									_storage.assocUnstableUnits[ parent_unit ].is_free = 0;
								}
							}
						)
					}
				);
			}

			//
			//	insert unit_witnesses
			//
			if ( Array.isArray( objUnit.witnesses ) )
			{
				for ( i = 0; i < objUnit.witnesses.length; i ++ )
				{
					address	= objUnit.witnesses[ i ];
					conn.addQuery
					(
						arrQueries,
						"INSERT INTO unit_witnesses ( unit, address ) VALUES( ?, ? )",
						[
							objUnit.unit,
							address
						]
					);
				}

				conn.addQuery
				(
					arrQueries,
					"INSERT " + conn.getIgnore() + " INTO witness_list_hashes (witness_list_unit, witness_list_hash) VALUES (?,?)",
					[
						objUnit.unit,
						_object_hash.getBase64Hash( objUnit.witnesses )
					]
				);
			}


			//
			//	build author addresses
			//
			arrAuthorAddresses	= [];
			for ( i = 0; i < objUnit.authors.length; i++ )
			{
				author	= objUnit.authors[ i ];

				arrAuthorAddresses.push( author.address );

				//	...
				definition		= author.definition;
				definition_chash	= null;

				if ( definition )
				{
					//	IGNORE for messages out of sequence
					definition_chash	= _object_hash.getChash160( definition );

					//	...
					conn.addQuery
					(
						arrQueries,
						"INSERT " + conn.getIgnore() + " INTO definitions \n\
						( definition_chash, definition, has_references ) \n\
						VALUES ( ?, ?, ? )",
						[
							definition_chash,
							JSON.stringify( definition ),
							_definition.hasReferences( definition ) ? 1 : 0
						]
					);

					//
					//	actually inserts only when the address is first used.
					//	if we change keys and later send a unit signed by new keys, the address is not inserted.
					//	Its definition_chash was updated before when we posted change-definition message.
					//
					if ( definition_chash === author.address )
					{
						conn.addQuery
						(
							arrQueries,
							"INSERT " + conn.getIgnore() + " INTO addresses ( address ) VALUES( ? )",
							[
								author.address
							]
						);
					}
				}
				else if ( objUnit.content_hash )
				{
					conn.addQuery
					(
						arrQueries,
						"INSERT " + conn.getIgnore() + " INTO addresses ( address ) VALUES( ? )",
						[
							author.address
						]
					);
				}

				conn.addQuery
				(
					arrQueries,
					"INSERT INTO unit_authors ( unit, address, definition_chash ) VALUES( ?, ?, ? )",
					[
						objUnit.unit,
						author.address,
						definition_chash
					]
				);
				if ( bGenesis )
				{
					conn.addQuery
					(
						arrQueries,
						"UPDATE unit_authors SET _mci=0 WHERE unit=?",
						[
							objUnit.unit
						]
					);
				}

				if ( ! objUnit.content_hash )
				{
					for ( path in author.authentifiers )
					{
						if ( ! author.authentifiers.hasOwnProperty( path ) )
						{
							continue;
						}

						//	...
						conn.addQuery
						(
							arrQueries,
							"INSERT INTO authentifiers ( unit, address, path, authentifier ) VALUES( ?, ?, ?, ? )",
							[
								objUnit.unit,
								author.address,
								path,
								author.authentifiers[ path ]
							]
						);
					}
				}
			}

			if ( ! objUnit.content_hash )
			{
				for ( i = 0; i < objUnit.messages.length; i ++ )
				{
					message		= objUnit.messages[ i ];
					text_payload	= null;

					if ( message.app === "text" )
					{
						text_payload	= message.payload;
					}
					else if ( message.app === "data" ||
						message.app === "profile" ||
						message.app === "attestation" ||
						message.app === "definition_template" )
					{
						text_payload	= JSON.stringify( message.payload );
					}

					//
					//	...
					//
					conn.addQuery
					(
						arrQueries,
						"INSERT INTO messages \n\
						( unit, message_index, app, payload_hash, payload_location, payload, payload_uri, payload_uri_hash ) \n\
						VALUES( ?, ?, ?, ?, ?, ?, ?, ? )",
						[
							objUnit.unit,
							i,
							message.app,
							message.payload_hash,
							message.payload_location,
							text_payload,
							message.payload_uri,
							message.payload_uri_hash
						]
					);
					if ( message.payload_location === "inline" )
					{
						switch ( message.app )
						{
						case "address_definition_change":
							definition_chash	= message.payload.definition_chash;
							address			= message.payload.address || objUnit.authors[ 0 ].address;

							//	...
							conn.addQuery
							(
								arrQueries,
								"INSERT INTO address_definition_changes \
								( unit, message_index, address, definition_chash ) \
								VALUES( ?, ?, ?, ? )",
								[
									objUnit.unit,
									i,
									address,
									definition_chash
								]
							);
							break;

						case "poll":
							poll	= message.payload;

							//	...
							conn.addQuery
							(
								arrQueries,
								"INSERT INTO polls (unit, message_index, question) VALUES(?,?,?)",
								[
									objUnit.unit,
									i,
									poll.question
								]
							);
							for ( j = 0; j < poll.choices.length; j ++ )
							{
								conn.addQuery
								(
									arrQueries,
									"INSERT INTO poll_choices (unit, choice_index, choice) VALUES(?,?,?)",
									[
										objUnit.unit,
										j,
										poll.choices[ j ]
									]
								);
							}
							break;

						case "vote":
							vote = message.payload;

							//	...
							conn.addQuery
							(
								arrQueries,
								"INSERT INTO votes (unit, message_index, poll_unit, choice) VALUES (?,?,?,?)",
								[
									objUnit.unit,
									i,
									vote.unit,
									vote.choice
								]
							);
							break;

						case "attestation":
							attestation	= message.payload;

							//	...
							conn.addQuery
							(
								arrQueries,
								"INSERT INTO attestations (unit, message_index, attestor_address, address) VALUES(?,?,?,?)",
								[
									objUnit.unit,
									i,
									objUnit.authors[ 0 ].address,
									attestation.address
								]
							);

							for ( field in attestation.profile )
							{
								if ( ! attestation.profile.hasOwnProperty( field ) )
								{
									continue;
								}

								//	...
								value	= attestation.profile[ field ];
								if ( field.length <= _constants.MAX_PROFILE_FIELD_LENGTH &&
									typeof value === 'string' &&
									value.length <= _constants.MAX_PROFILE_VALUE_LENGTH )
								{
									//	...
									conn.addQuery
									(
										arrQueries,
										"INSERT INTO attested_fields (unit, message_index, attestor_address, address, field, value) VALUES(?,?, ?,?, ?,?)",
										[
											objUnit.unit,
											i,
											objUnit.authors[ 0 ].address,
											attestation.address,
											field,
											value
										]
									);
								}
							}
							break;

						case "asset":
							asset	= message.payload;

							//	...
							conn.addQuery
							(
								arrQueries,
								"INSERT INTO assets (unit, message_index, \n\
									cap, is_private, is_transferrable, auto_destroy, fixed_denominations, \n\
									issued_by_definer_only, cosigned_by_definer, spender_attested, \n\
									issue_condition, transfer_condition ) \n\
								VALUES(?,?,?,?,?,?,?,?,?,?,?,?)",
								[
									objUnit.unit,
									i,
									asset.cap,
									asset.is_private ? 1 : 0,
									asset.is_transferrable ? 1 : 0,
									asset.auto_destroy ? 1 : 0,
									asset.fixed_denominations ? 1 : 0,
									asset.issued_by_definer_only ? 1 : 0,
									asset.cosigned_by_definer ? 1 : 0,
									asset.spender_attested ? 1 : 0,
									asset.issue_condition ? JSON.stringify( asset.issue_condition ) : null,
									asset.transfer_condition ? JSON.stringify( asset.transfer_condition ) : null
								]
							);

							if ( asset.attestors )
							{
								for ( j = 0; j < asset.attestors.length; j ++ )
								{
									conn.addQuery
									(
										arrQueries,
										"INSERT INTO asset_attestors (unit, message_index, asset, attestor_address) VALUES(?,?,?,?)",
										[
											objUnit.unit,
											i,
											objUnit.unit,
											asset.attestors[ j ]
										]
									);
								}
							}
							if ( asset.denominations )
							{
								for ( j = 0; j < asset.denominations.length; j ++ )
								{
									conn.addQuery
									(
										arrQueries,
										"INSERT INTO asset_denominations (asset, denomination, count_coins) VALUES(?,?,?)",
										[
											objUnit.unit,
											asset.denominations[ j ].denomination,
											asset.denominations[ j ].count_coins
										]
									);
								}
							}
							break;

						case "asset_attestors":
							asset_attestors = message.payload;

							for ( j = 0; j < asset_attestors.attestors.length; j ++ )
							{
								conn.addQuery
								(
									arrQueries,
									"INSERT INTO asset_attestors \n\
									(unit, message_index, asset, attestor_address) \n\
									VALUES(?,?,?,?)",
									[
										objUnit.unit,
										i,
										asset_attestors.asset,
										asset_attestors.attestors[ j ]
									]
								);
							}
							break;

						case "data_feed":
							data = message.payload;
							for ( feed_name in data )
							{
								if ( ! data.hasOwnProperty( feed_name ) )
								{
									continue;
								}

								//	...
								value		= data[ feed_name ];
								field_name	= ( typeof value === 'string' ) ? "`value`" : "int_value";

								//	...
								conn.addQuery
								(
									arrQueries,
									"INSERT INTO data_feeds \n\
									(unit, message_index, feed_name, " + field_name + ") \n\
									VALUES(?,?,?,?)",
									[
										objUnit.unit,
										i,
										feed_name,
										value
									]
								);
							}
							break;

						case "payment":
							//	we'll add inputs/outputs later because we need to read the payer address
							//	from src outputs, and it's inconvenient to read it synchronously
							break;
						}	// switch message.app
					}	// inline

					if ( "spend_proofs" in message )
					{
						for ( j = 0; j < message.spend_proofs.length; j ++ )
						{
							objSpendProof	= message.spend_proofs[ j ];

							//	...
							conn.addQuery
							(
								arrQueries,
								"INSERT INTO spend_proofs \n\
								( unit, message_index, spend_proof_index, spend_proof, address ) \n\
								VALUES( ?,?,?,?,? )",
								[
									objUnit.unit,
									i,
									j,
									objSpendProof.spend_proof,
									objSpendProof.address || arrAuthorAddresses[ 0 ]
								]
							);
						}
					}
				}
			}

			if ( "earned_headers_commission_recipients" in objUnit )
			{
				for ( i = 0; i < objUnit.earned_headers_commission_recipients.length; i ++ )
				{
					recipient	= objUnit.earned_headers_commission_recipients[ i ];

					//	...
					conn.addQuery
					(
						arrQueries,
						"INSERT INTO earned_headers_commission_recipients \n\
						( unit, address, earned_headers_commission_share ) \n\
						VALUES( ?, ?, ? )",
						[
							objUnit.unit,
							recipient.address,
							recipient.earned_headers_commission_share
						]
					);
				}
			}




			function determineInputAddressFromSrcOutput( asset, denomination, input, handleAddress )
			{
				conn.query
				(
					"SELECT address, denomination, asset \n\
					FROM outputs \n\
					WHERE unit=? AND message_index=? AND output_index=?",
					[
						input.unit,
						input.message_index,
						input.output_index
					],
					function( rows )
					{
						if ( rows.length > 1 )
						{
							throw Error( "multiple src outputs found" );
						}
						if ( rows.length === 0 )
						{
							if ( _conf.bLight )
							{
								//	it's normal that a light client doesn't store the previous output
								return handleAddress( null );
							}
							else
							{
								throw Error( "src output not found" );
							}
						}

						var row	= rows[ 0 ];
						if ( ! ( ! asset && ! row.asset || asset === row.asset ) )
						{
							throw Error( "asset doesn't match" );
						}
						if ( denomination !== row.denomination )
						{
							throw Error( "denomination doesn't match" );
						}

						var address = row.address;
						if ( arrAuthorAddresses.indexOf( address ) === -1 )
						{
							throw Error( "src output address not among authors" );
						}

						//	...
						handleAddress( address );
					}
				);
			}

			function addInlinePaymentQueries( cb )
			{
				//
				//	_async.forEachOfSeries is an alias of _async.eachOfSeries
				//
				//	eachOfSeries( coll, iteratee, [opt]callback )
				//	- runs only a single _async operation at a time.
				//
				//	see details in https://caolan.github.io/async/docs.html#eachOfSeries
				//
				_async.forEachOfSeries
				(
					objUnit.messages,
					function( message, i, cb2 )
					{
						if ( message.payload_location !== 'inline' )
						{
							return cb2();
						}

						//	...
						var payload = message.payload;
						if ( message.app !== 'payment' )
						{
							return cb2();
						}

						//	...
						var denomination = payload.denomination || 1;

						//	...
						_async.forEachOfSeries
						(
							payload.inputs,
							function( input, j, cb3 )
							{
								var type			= input.type || "transfer";
								var src_unit			= ( type === "transfer" ) ? input.unit : null;
								var src_message_index		= ( type === "transfer" ) ? input.message_index : null;
								var src_output_index		= ( type === "transfer" ) ? input.output_index : null;
								var from_main_chain_index	= ( type === "witnessing" || type === "headers_commission" ) ? input.from_main_chain_index : null;
								var to_main_chain_index		= ( type === "witnessing" || type === "headers_commission" ) ? input.to_main_chain_index : null;

								//	...
								function determineInputAddress( handleAddress )
								{
									if ( type === "headers_commission" || type === "witnessing" || type === "issue" )
									{
										return handleAddress
										(
											( arrAuthorAddresses.length === 1 ) ? arrAuthorAddresses[ 0 ] : input.address
										);
									}

									//	hereafter, transfer
									if ( arrAuthorAddresses.length === 1 )
									{
										return handleAddress( arrAuthorAddresses[ 0 ] );
									}

									//	...
									determineInputAddressFromSrcOutput
									(
										payload.asset,
										denomination,
										input,
										handleAddress
									);
								}

								//	...
								determineInputAddress
								(
									function( address )
									{
										var is_unique = objValidationState.arrDoubleSpendInputs.some
										(
											function( ds )
											{
												return ( ds.message_index === i && ds.input_index === j );
											}
										)
										? null : 1;

										conn.addQuery
										(
											arrQueries,
											"INSERT INTO inputs \n\
											(unit, message_index, input_index, type, \n\
											src_unit, src_message_index, src_output_index, \
											from_main_chain_index, to_main_chain_index, \n\
											denomination, amount, serial_number, \n\
											asset, is_unique, address) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
											[
												objUnit.unit,
												i,
												j,
												type,
									 			src_unit,
												src_message_index,
												src_output_index,
									 			from_main_chain_index,
												to_main_chain_index,
									 			denomination,
												input.amount,
												input.serial_number,
									 			payload.asset,
												is_unique,
												address
											]
										);
										switch ( type )
										{
										case "transfer":
											conn.addQuery
											(
												arrQueries,
												"UPDATE outputs SET is_spent=1 WHERE unit=? AND message_index=? AND output_index=?",
												[
													src_unit,
													src_message_index,
													src_output_index
												]
											);
											break;
										case "headers_commission":
										case "witnessing":
											var table	= type + "_outputs";
											conn.addQuery
											(
												arrQueries,
												"UPDATE " + table + " SET is_spent=1 \n\
												WHERE main_chain_index>=? AND main_chain_index<=? AND address=?",
												[
													from_main_chain_index,
													to_main_chain_index,
													address
												]
											);
											break;
										}

										//	...
										cb3();
									}
								);
							},
							function()
							{
								for ( var j = 0; j < payload.outputs.length; j++ )
								{
									var output	= payload.outputs[ j ];
									//
									//	we set is_serial=1 for public payments as we check that their inputs are stable and serial before spending,
									//	therefore it is impossible to have a nonserial in the middle of the chain (but possible for private payments)
									//
									conn.addQuery
									(
										arrQueries,
										"INSERT INTO outputs \
										( unit, message_index, output_index, address, amount, asset, denomination, is_serial ) \
										VALUES( ?, ?, ?, ?, ?, ?, ?, 1 )",
										[
											objUnit.unit,
											i,
											j,
											output.address,
											parseInt( output.amount ),
											payload.asset,
											denomination
										]
									);
								}

								//	...
								cb2();
							}
						);
					},
					cb
				);
			}

			function updateBestParent( cb )
			{
				//	choose best parent among compatible parents only
				conn.query
				(
					"SELECT unit \n\
					FROM units AS parent_units \n\
					WHERE unit IN(?) \n\
						AND (witness_list_unit=? OR ( \n\
							SELECT COUNT(*) \n\
							FROM unit_witnesses \n\
							JOIN unit_witnesses AS parent_witnesses USING(address) \n\
							WHERE parent_witnesses.unit IN(parent_units.unit, parent_units.witness_list_unit) \n\
								AND unit_witnesses.unit IN(?, ?) \n\
						)>=?) \n\
					ORDER BY witnessed_level DESC, \n\
						level-witnessed_level ASC, \n\
						unit ASC \n\
					LIMIT 1",
					[
						objUnit.parent_units,
						objUnit.witness_list_unit,
						objUnit.unit,
						objUnit.witness_list_unit,
						_constants.COUNT_WITNESSES - _constants.MAX_WITNESS_LIST_MUTATIONS
					],
					function( rows )
					{
						if ( rows.length !== 1 )
						{
							throw Error( "zero or more than one best parent unit?" );
						}

						//	...
						my_best_parent_unit	= rows[ 0 ].unit;
						if ( my_best_parent_unit !== objValidationState.best_parent_unit )
						{
							_throwError
							(
								"different best parents, validation: "
								+ objValidationState.best_parent_unit
								+ ", writer: " + my_best_parent_unit
							);
						}

						//	...
						conn.query
						(
							"UPDATE units SET best_parent_unit=? WHERE unit=?",
							[
								my_best_parent_unit,
								objUnit.unit
							],
							function()
							{
								cb();
							}
						);
					}
				);
			}

			function determineMaxLevel( handleMaxLevel )
			{
				var max_level = 0;

				//	...
				_async.each
				(
					objUnit.parent_units,
					function( parent_unit, cb )
					{
						_storage.readStaticUnitProps
						(
							conn,
							parent_unit,
							function( props )
							{
								if ( props.level > max_level )
								{
									max_level = props.level;
								}

								//	...
								cb();
							}
						);
					},
					function()
					{
						handleMaxLevel( max_level );
					}
				);
			}

			function updateLevel( cb )
			{
				conn.query
				(
					"SELECT MAX(level) AS max_level FROM units WHERE unit IN(?)",
					[
						objUnit.parent_units
					],
					function( rows )
					{
						if ( rows.length !== 1 )
						{
							throw Error( "not a single max level?" );
						}

						//	...
						determineMaxLevel
						(
							function( max_level )
							{
								if ( max_level !== rows[ 0 ].max_level )
								{
									_throwError
									(
										"different max level, sql: "
										+ rows[ 0 ].max_level + ", props: " + max_level
									);
								}

								//	...
								objNewUnitProps.level	= max_level + 1;
								conn.query
								(
									"UPDATE units SET level=? WHERE unit=?",
									[
										rows[ 0 ].max_level + 1,
										objUnit.unit
									],
									function()
									{
										cb();
									}
								);
							}
						);
					}
				);
			}

			function updateWitnessedLevel( cb )
			{
				if ( objUnit.witnesses )
				{
					updateWitnessedLevelByWitnesslist( objUnit.witnesses, cb );
				}
				else
				{
					_storage.readWitnessList
					(
						conn,
						objUnit.witness_list_unit,
						function( arrWitnesses )
						{
							updateWitnessedLevelByWitnesslist( arrWitnesses, cb );
						}
					);
				}
			}

			//
			//	The level at which we collect at least 7 distinct witnesses while walking up the main chain from our unit.
			//	The unit itself is not counted even if it is authored by a witness
			//
			function updateWitnessedLevelByWitnesslist( arrWitnesses, cb )
			{
				var arrCollectedWitnesses = [];

				function setWitnessedLevel( witnessed_level )
				{
					//	PPP
					_profilerex.begin( 'writer-saveJoint-wl-update' );

					if ( witnessed_level !== objValidationState.witnessed_level )
					{
						_throwError
						(
							"different witnessed levels, validation: "
							+ objValidationState.witnessed_level
							+ ", writer: " + witnessed_level
						);
					}

					//	...
					objNewUnitProps.witnessed_level	= witnessed_level;
					conn.query
					(
						"UPDATE units SET witnessed_level=? WHERE unit=?",
						[
							witnessed_level,
							objUnit.unit
						],
						function()
						{
							//	PPP
							_profilerex.end( 'writer-saveJoint-wl-update' );

							//	...
							cb();
						}
					);
				}

				function addWitnessesAndGoUp( start_unit )
				{
					//	PPP
					_profilerex.begin( 'writer-saveJoint-wl-select-bp' );

					//	...
					_storage.readStaticUnitProps
					(
						conn,
						start_unit,
						function( props )
						{
							//	PPP
							_profilerex.end( 'writer-saveJoint-wl-select-bp' );

							//	...
							var best_parent_unit	= props.best_parent_unit;
							var level		= props.level;

							if ( level === null )
							{
								throw Error( "null level in updateWitnessedLevel" );
							}
							if ( level === 0 )
							{
								//	genesis
								return setWitnessedLevel( 0 );
							}

							//	PPP
							_profilerex.begin( 'writer-saveJoint-wl-select-authors' );

							//	...
							_storage.readUnitAuthors
							(
								conn,
								start_unit,
								function( arrAuthors )
								{
									//	PPP
									_profilerex.end( 'writer-saveJoint-wl-select-authors' );

									//	PPP
									_profilerex.begin( 'writer-saveJoint-wl-search' );

									for ( var i = 0; i < arrAuthors.length; i ++ )
									{
										var address	= arrAuthors[ i ];

										if ( arrWitnesses.indexOf( address ) !== -1 &&
											arrCollectedWitnesses.indexOf( address ) === -1 )
										{
											arrCollectedWitnesses.push( address );
										}
									}

									//	PPP
									_profilerex.end( 'writer-saveJoint-wl-search' );

									//	...
									( arrCollectedWitnesses.length < _constants.MAJORITY_OF_WITNESSES )
									?
										addWitnessesAndGoUp( best_parent_unit )
										:
										setWitnessedLevel( level );
								}
							);
						}
					);
				}

				//	...
				addWitnessesAndGoUp( my_best_parent_unit );
			}



			////////////////////////////////////////////////////////////////////////////////
			//
			//	EXECUTE
			//
			////////////////////////////////////////////////////////////////////////////////

			//
			//	create new unit
			//
			var objNewUnitProps =
				{
					unit				: objUnit.unit,
					level				: bGenesis ? 0 : null,
					latest_included_mc_index	: null,
					main_chain_index		: bGenesis ? 0 : null,
					is_on_main_chain		: bGenesis ? 1 : 0,
					is_free				: 1,
					is_stable			: bGenesis ? 1 : 0,
					witnessed_level			: bGenesis ? 0 : null,
					parent_units			: objUnit.parent_units
				};


			//	PPP
			_profilerex.begin( 'writer-saveJoint-mutexGetLock' );

			//
			//	without this locking, we get frequent deadlocks from mysql
			//
			_mutex.lock
			(
				[ "write" ],
				function( unlock )
				{
					_profilerex.end( 'writer-saveJoint-mutexGetLock' );

					//	...
					_log.consoleLog( "got lock to write " + objUnit.unit );

					//
					//	save the unit
					//
					_storage.assocUnstableUnits[ objUnit.unit ] = objNewUnitProps;


					//	PPP
					_profilerex.begin( 'writer-saveJoint-addInlinePaymentQueries' );

					//
					//	...
					//
					addInlinePaymentQueries
					(
						function()
						{
							//	PPP
							_profilerex.end( 'writer-saveJoint-addInlinePaymentQueries' );

							//	PPP
							_profilerex.begin( 'writer-saveJoint-execute-series' );

							//	...
							_async.series
							(
								arrQueries,
								function()
								{
									//	PPP
									_profilerex.end( 'writer-saveJoint-execute-series' );

									//	...
									var arrOps = [];

									if ( objUnit.parent_units )
									{
										if ( ! _conf.bLight )
										{
											arrOps.push( updateBestParent );
											arrOps.push( updateLevel );
											arrOps.push( updateWitnessedLevel );
											arrOps.push
											(
												function( cb )
												{
													_log.consoleLog( "updating MC after adding " + objUnit.unit );
													_main_chain.updateMainChain( conn, null, objUnit.unit, cb );
												}
											);
										}

										if ( preCommitCallback )
										{
											arrOps.push
											(
												function( cb )
												{
													_log.consoleLog( "executing pre-commit callback" );
													preCommitCallback( conn, cb );
												}
											);
										}
									}

									//	PPP
									_profilerex.begin( 'writer-saveJoint-arrOps-series' );

									//	...
									_async.series
									(
										arrOps,
										function( err )
										{
											//	PPP
											_profilerex.end( 'writer-saveJoint-arrOps-series' );

											//	PPP
											_profilerex.begin( 'writer-saveJoint-ROLLBACK-COMMIT' );

											//	...
											conn.query
											(
												err ? "ROLLBACK" : "COMMIT",
												function()
												{
													//	PPP
													_profilerex.end( 'writer-saveJoint-ROLLBACK-COMMIT' );

													//	...
													conn.release();
													_log.consoleLog
													(
														( err ? ( err + ", therefore rolled back unit " ) : "committed unit " ) + objUnit.unit
													);

													//
													//	we have processed a unit
													//	successful or failed
													//
													_profilerex.increase();

													//	...
													if ( err )
													{
														_storage.resetUnstableUnits( unlock );
													}
													else
													{
														unlock();
													}

													if ( ! err )
													{
														_event_bus.emit( 'saved_unit-' + objUnit.unit, objJoint );
													}
													if ( onDone )
													{
														onDone( err );
													}

													//	...
													m_nCountWrites ++;
													if ( _conf.storage === 'sqlite' )
													{
														//	PPP
														_profilerex.begin( 'writer-saveJoint-_updateSQLiteStats' );

														//	...
														_updateSQLiteStats();

														//	PPP
														_profilerex.end( 'writer-saveJoint-_updateSQLiteStats' );
													}
												}
											);
										}
									);
								}
							);
						}
					);
				}
			);
		}
		//	end of callback _db.takeConnectionFromPool
	);
}





function _readCountOfAnalyzedUnits( handleCount )
{
	if ( m_nCountUnitsInPrevAnalyze )
	{
		return handleCount( m_nCountUnitsInPrevAnalyze );
	}

	//	...
	_db.query
	(
		"SELECT * FROM sqlite_master WHERE type='table' AND name='sqlite_stat1'",
		function( rows )
		{
			if ( rows.length === 0 )
			{
				return handleCount( 0 );
			}

			_db.query
			(
				"SELECT stat FROM sqlite_stat1 WHERE tbl='units' AND idx='sqlite_autoindex_units_1'",
				function( rows )
				{
					if ( rows.length !== 1 )
					{
						_log.consoleLog( 'no stat for sqlite_autoindex_units_1' );
						return handleCount( 0 );
					}

					//	...
					handleCount( parseInt( rows[ 0 ].stat.split( ' ' )[ 0 ] ) );
				}
			);
		}
	);
}


/**
 *	update stats for query planner
 */
function _updateSQLiteStats()
{
	if ( m_nCountWrites === 1 )
	{
		m_nStartTime = Date.now();
		m_nPrevTime = Date.now();
	}
	if ( m_nCountWrites % 100 !== 0 )
	{
		return;
	}

	if ( m_nCountWrites % 1000 === 0 )
	{
		var total_time		= ( Date.now() - m_nStartTime ) / 1000;
		var recent_time		= ( Date.now() - m_nPrevTime ) / 1000;
		var recent_tps		= 1000 / recent_time;
		var avg_tps		= m_nCountWrites / total_time;

		m_nPrevTime		= Date.now();
		//	console.error(m_nCountWrites+" units done in "+total_time+" s, recent "+recent_tps+" tps, avg "+avg_tps+" tps");
	}

	//	...
	_db.query
	(
		"SELECT MAX(rowid) AS count_units FROM units",
		function( rows )
		{
			var count_units	= rows[ 0 ].count_units;
			if ( count_units > 500000 )
			{
				//	the _db is too big
				return;
			}

			_readCountOfAnalyzedUnits
			(
				function( count_analyzed_units )
				{
					_log.consoleLog( 'count analyzed units: ' + count_analyzed_units );
					if ( count_units < 2 * count_analyzed_units )
					{
						return;
					}

					//	...
					m_nCountUnitsInPrevAnalyze	= count_units;
					_log.consoleLog( "will update sqlite stats" );

					//
					//	TODO
					//	ANALYZE ? what ?
					//
					_db.query
					(
						"ANALYZE",
						function()
						{
							//
							//	TODO
							//	ANALYZE sqlite_master ? what ?
							//
							_db.query
							(
								"ANALYZE sqlite_master",
								function()
								{
									_log.consoleLog( "sqlite stats updated" );
								}
							);
						}
					);
				}
			);
	});
}



function _throwError( msg )
{
	if ( typeof window === 'undefined' )
	{
		throw Error(msg);
	}
	else
	{
		_event_bus.emit( 'nonfatal_error', msg, new Error() );
	}
}






/**
 *	exports
 */
exports.saveJoint	= saveJoint;
